---
title: "面向对象"
thumbnail: "/assets/img/thumbnail/javase.png"
date: "2017-03-01"
---

# 核心概念

![面向对象](/assets/img/thumbnail/javase.png)

---

# 什么是面向对象,面向过程(POP)和面向对象(OOP)的区别

- **面向过程**：是分析解决问题的**步骤**，然后用**函数**把这些步骤一步一步地实现，然后在使用的时候一一调用则可。**性能较高**，所以**单片机**、**嵌入式**开发等一般采用面向过程开发

- **面向对象**：是把构成问题的事务分解成各个**对象**，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为。面向对象有**封装、继承、多态**的特性，所以**易维护、易复用、易扩展**。可以设计出**低耦合**的系统。 但是**性能**上来说，比面向过程要**低**。
  
  - 特性：封装、继承、多态。
  
  - 优点：使系统更加灵活，易维护、易复用、易扩展。

---

# 数据类型

| 基本类型    | 大小(字节) | 默认值          | 封装类       |
|---------|--------|--------------|-----------|
| byte    | 1      | (byte)0      | Byte      |
| short   | 2      | (short)0     | Short     |
| int     | 4      | 0            | Integer   |
| long    | 8      | 0l           | Long      |
| float   | 4      | 0.0f         | Float     |
| double  | 8      | 0.0d         | Double    |
| boolean | -      | false        | Boolean   |
| char    | 2      | \u0000(null) | Character |

boolean类型占了单独使用是int 4个字节，在数组中是1个字节

Integer 和 Integer 类型的比较中。如果数值范围在[-128,127]之间可以用 == 。其他范围只能用 equals 方法
原因是：JVM会维护这个范围内的缓存，比如第一个Integer是127，会存放在缓存中；在创建第二个Integer时会直接返回缓存的127，所以两者是相等的

> 基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间，必须通过实例化开辟数据空间之后才可以赋值。<br>
> 数组对象也是一个引用对象，将一个数组赋值给另一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看的见。<br>
> 虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。<br>
> 在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素boolean元素占8位。<br>
> 这样我们可以得出boolean类型占了单独使用是4个字节，在数组中又是1个字节。使用int的原因是，对于当下32位的处理器（CPU）来说，一次处理数是32位（这里不是指的是32/64位系统，而是指CPU硬件层面），具有高效存取的特点。

## String相关

- String
  - 在java8中String使用char数组存储数据
  - 在java9中String使用byte数组存储字符串，并且同时使用coder来标识使用了哪种编码
  - StringPool(StringTable),
    - StringPool是Java中的一个字符串常量池，用于存储字符串对象的引用。它是在堆内存中的一个特殊区域，用于提高字符串的重复利用率和节省内存空间。
    - StringPool中的字符串对象是不可变的，一旦创建就不能被修改。这是因为字符串的不可变性可以提高字符串的安全性和线程安全性。
    - StringPool的实现方式有两种：基于永久代的实现方式和基于堆的实现方式。在Java8之后，永久代被元空间取代，StringPool被移至堆中。
    - StringPool中的字符串对象是通过字符串字面量创建的，也可以通过调用String类的intern()方法将字符串对象添加到StringPool中。
    - StringPool的主要作用是提高字符串的重复利用率。当程序中多次使用相同的字符串字面量时，它们都将指向StringPool中的同一个字符串对象，从而节省了内存空间。
    - StringPool的另一个作用是加速字符串的比较。由于StringPool中的字符串对象是唯一的，可以通过比较字符串对象的引用来判断两个字符串是否相等，从而提高了比较的效率。
    - StringPool的大小是有限的，它的最大容量取决于具体的Java虚拟机实现。当StringPool中的字符串对象达到一定数量时，新的字符串对象将不再被添加到StringPool中，而是在堆中创建新的字符串对象。
  - String为什么被声明为final(声明为final的好处？)
    - 对于Map容器来说要求key不可变，所以字符串常量池要求String不可变。
- StringBuilder
  - 线程不安全，可以被改变
- StringBuffer
  - 线程安全，内部被synchronized同步

---

## 标识符的命名规则

- **标识符的含义**： 是指在程序中，我们自己定义的内容，譬如，类的名字，方法名称以及变量名称等等，都是标识符。
- **命名规则**：（硬性要求） 标识符可以包含**英文字母**，**0-9的数字**，**$**以及**_** 标识符不能以数字开头，标识符不是关键字
- **命名规范**：（非硬性要求） 类名规范：首字符大写，后面每个单词首字母大写（大驼峰式）。 变量名规范：首字母小写，后面每个单词首字母大写（小驼峰式）。 方法名规范：同变量名。

---

## instanceof

instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例，用法为：

```java
boolean result = obj instanceof Class
```

其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。
**注意**：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。

```java
int i = 0;
System.out.println(i instanceof Integer);//编译不通过 i必须是引用类型，不能是基本类型
System.out.println(i instanceof Object);//编译不通过

Integer integer = new Integer(1);
System.out.println(integer instanceof Integer);//true

//false ,在 JavaSE规范 中对 instanceof 运算符的规定就是：如果 obj 为 null，那么将返回 false。
System.out.println(null instanceof Object);
```

---

# 封装

![封装](/assets/img/thumbnail/封装.png)

目的：提高安全性<br>
在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这三种：成员内部类、局部内部类、匿名内部类，如下图所示：
![内部类](/assets/img/thumbnail/内部类.png)

## 普通内部类

定义在类中的类，可以使用外部类所有属性和方法。普通内部类属于具体对象，因此不能声明 static 成员变量和方法。
成员内部类依附外部类而存在。也就是说，如果要创建普通内部类的对象，就必须首先存在外部类的对象。

```java
public class Test {
    public static void main(String[] args)  {
        // 创建内部类
        Outter outter = new Outter();
        Outter.Inner inner = outter.new Inner();  
        inner.output();
    }
}

// 外部类 
class Outter {
    private int num = "10";
    // 内部类  
    class Inner {
        void output(){
            System.out.println(num);
        }
    }
}
```

## 局部内部类

定义在一个方法或者一个作用域里的内部类。对局部内部类的访问仅限于方法内或者该作用域内，且局部内部类不能被访问权限所修饰。

```java
public class Test {
    public static void main(String[] args)  {
        // 创建内部类
        Factory f = new Factory();
        Gun myrifle = f.getRifle();  
    }
}

class Factory {
    // 局部内部类
    public Gun getRifle(){
        class Rifle extends Gun {   
            int len = 60;
        }
        return new Rifle();
    }
}
```

## 匿名内部类

匿名内部类不用定义名称，但必须继承一个父类或实现一个接口。由于没有类名，匿名内部类不能定义构造器。在创建匿名内部类的时候会立即创建它的实例。因此匿名内部类只能使用一次，通常用来简化代码编写。
最常用的情况就是在多线程的实现上，创建线程类传入参数需要继承 Thread 类或实现 Runnable 接口。

```java
// 父类或接口
interface Person {
    public void eat();
}

public class Demo {
    public static void main(String[] args) {
        Person p = new Person() { 
            // 定义匿名内部类并直接使用
            public void eat() {
                System.out.println("eat apple");
            }
        };
        p.eat();
    }
}
```

*JDK 1.8 中引入了 Lambda 表达式，你甚至连方法名都不需要写。*

```java
public class Demo {
    public static void main(String[] args) {
        Person p = new Person(() -> {
            System.out.println("eat apple");
        });
        p.eat();
    }
}
```

局部内部类和匿名内部类都定义在方法中，如果调用方法中的其他局部变量，只能调用外部类的局部 final 变量。因为在多线程中，外部类方法中定义的变量 A 在方法执行完毕后生命周期就结束了，而此时 Thread 对象的生命周期很可能还没有结束。内部类方法中访问的变量 A 实际上是拷贝。这就必须限定变量为 final，否则改动将导致数据不一致。

```java
public class Test {
    public void test(final int b) {
        final int a = 10;
        new Thread(){
            public void run() {
                System.out.println(a);
                System.out.println(b);
            };
        }.start();
    }
}
```

## 静态内部类

静态内部类是不需要依赖于外部类，可以在不创建外部类对象的情况下创建内部类的对象。静态内部类不能使用外部类的非 static 成员变量或者方法。

```java
public class Test {
    public static void main(String[] args)  {
        // 无需外部对象，直接创建内部类
        Outter.Inner inner = new Outter.Inner();
    }
}

class Outter {
    static class Inner {
        int data = 0;
    }
}
```

---

# 继承

## 类的继承

子类继承父类后，无需定义也可使用父类定义好的 public/protected 方法和属性。也可以进行扩展和方法的重写。

- 父类的**属性值**不会被子类继承，但子类可以通过父类提供的方法得到父类的属性值。
- 父类的 **static 方法**不会被子类继承，子类的 static 方法会隐藏父类的同名 static 方法。
- 父类的**构造方法**不会被子类继承，子类必须在构造方法首行调用父类构造方法（先构造父类，再构造子类）

```java
final public class Trunk extends Car{ 
    // 重定义属性（未公开无法继承）
    String brand;
    String description = "this is a trunk";
    // 扩展属性
    int goods;
    // 扩展方法              
    public void load(int num){
        this.goods += num;
    }
    // 子类构造方法
    public Trunk(String brand){    
        super(brand);        
        this.goods = 0;                          
    }
    // 重写方法
    @Override         
    public void go(String loc){
        super.go(loc);                            
        System.out.print(" with" + goods + "goods"); 
        this.goods = 0;
    }
}
```

*Object 类是一切 java 类的父类。对于普通的 java 类,即便不声明也默认继承了 Object 类。*

## 接口继承

和类的继承类似。但 Java 类只能单继承，而 Java 接口可以多继承。

```java
interface Charge extends Move, Fight{  
    public abstract void kill(int num);
}
```

---

# 多态

## 继承多态

- **重载**(overload)：定义多种同名方法，调用时根据传入参数判定调用哪种方法。
- **重写**(override)：子类定义完全相同的方法覆盖父类。

重写是多态的前提，其允许父类引用指向子类对象（引用类型为父类，指向的实际对象类型为子类）。

`Car mycar = new Trunk("Benz");`

但不允许子类引用指向父类对象。

~~`Trunk mycar = new Car("Benz");`~~   

如果两个类之间存在继承关系，可以进行强制类型转换。强制类型转换只能改变引用类型，实际指向对象类型不会发生变化。

`Trunk newCar = (Trunk)mycar; `

## 方法多态

- **调用普通方法**
  
  子类同名方法会覆盖父类。执行方法根据实际对象类型来判定，即执行子类重写的方法。 

- **调用 static / private / final 以及构造方法**
  
  特殊方法不能被覆盖，不存在多态。执行方法会根据引用类型来判定，即执行父类方法。

- **调用成员变量**
  
  父类属性值不会被子类继承，不存在多态。调用变量会根据引用类型来判定，即得到父类属性值。

```java
Car myCar = new Trunk("Benz");

myCar.go("London");                    // (trunk) go to London with 0 goods
myCar.showNum();                       // (car) 1
System.out.print(myCar.description);   // (car) this is a car

Trunk newCar = (Trunk)mycar;           // 强制类型转换
System.out.print(newCar.description);  // (trunk) this is a trunk
```

# 重载和重写的区别

- **重写(Override)**

   从字面上看，重写就是 重新写一遍的意思。其实就是在子类中把父类本身有的方法重新写一遍。子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类型(除过子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下， 对方法体进行修改或重写，这就是重写。但要注意子类函数的访问修饰权限不能少于父类的。

```java
public class Father {
 public static void main(String[] args) {
 // TODO Auto-generated method stub
 Son s = new Son();
 s.sayHello();
 }
 public void sayHello() {
 System.out.println("Hello");
 }
}
class Son extends Father{
 @Override
 public void sayHello() {
 // TODO Auto-generated method stub
 System.out.println("hello by ");
 }
}
```

子类只能够重写父类非私有的的，非静态的方法<br>
子类重写父类的静态方法，那不叫重写，因为不能使用Override注解，所以那叫叫覆盖，因为这样会导致父类的静态方法失效<br>
子类重写父类的方法可以扩大访问权限<br>
子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。

重写 总结：
1. 发生在父类与子类之间
2. 方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同
3. 访问修饰符的限制一定要大于被重写方法的访问修饰符（public>protected>default>private)
4. 重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常

- **重载（Overload）**

  在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同甚至是参数顺序不同）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但不能通过返回类型是否相同来判断重载。

```java
public class Father {
 public static void main(String[] args) {
 // TODO Auto-generated method stub
 Father s = new Father();
 s.sayHello();
 s.sayHello("wintershii");
 }
 public void sayHello() {
 System.out.println("Hello");
 }
 public void sayHello(String name) {
 System.out.println("Hello" + " " + name);
 }
}
```

重载 总结：

1. 重载Overload是一个类中多态性的一种表现
2. 重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序)
3. 重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准

## 反射机制

JAVA 是动态编译语言（运行时才确定类型），支持反射机制。在运行状态中

- 对于任意一个类，都能够知道这个类的所有属性和方法；
- 对于任意一个对象，都能够调用它的任意一个方法和属性。

通过反射机制能更好地支持多态，降低模块耦合，提高代码灵活度（根据传入类名不同，就能实例化出不同的对象）。

但是在性能上会有较大的损耗。

*尽管在应用层面很少使用反射机制，但在设计基础框架的时候反射机制非常有用。*

### 反射机制运用

类的相关信息保存在以下类中，通过特定方法获取其对象能够知道这个类的信息。

- **Class 类**：类
- **Constructor 类**：类的构造方法
- **Field 类**：类的属性
- **Method 类**：类的方法

```java
public class Reflection {
    public static void main(String[] args) {

        /************************** 获取 Class 对象 **************************/

        // 第一种方式 返回对象的类 【已有对象，获取类无意义】
        Student stu = new Student();
        Class stuClass = stu.getClass();

        // 第二种方式 获取数据类型的静态 class 属性 【需要导入类包】
        Class stuClass = Student.class;

        // 第三种方式 返回路径下的类 【常用】
        Class stuClass = Class.forName("Reflection.Student");

        /************************** 获取 Class 信息 **************************/

        // 获取类名
        String name = stuClass.getName());   

        // 获取类的公有构造方法
        Constructor[] conArray = stuClass.getConstructors();
        // 获取类的全部构造方法
        Constructor[] conArray = stuClass.getDeclaredConstructors();
        // 获取类的指定构造方法（参数）
        Constructor con = stuClass.getConstructor(null);
        Constructor con = stuClass.getDeclaredConstructor(char.class);

        // 获取类的公有属性
        Field[] fieldArray = stuClass.getFields(); 
        // 获取类的全部属性
        Field[] fieldArray = stuClass.getDeclaredFields();
        // 获取类的指定属性（属性名）
        Field f = stuClass.getField("name");    

        // 获取类的公有方法
        Method[] methodArray = stuClass.getMethods(); 
        // 获取类的全部方法                
        Method[] methodArray = stuClass.getDeclaredMethods();
        // 获取类的指定方法（方法名+形参类型）                  
        Method m = stuClass.getMethod("main", String.class);   

        /************************** 在对象中使用 **************************/

        Object obj = con.newInstance();   // 调用公有无参构造方法创建对象
        f.set(obj, "X-man");              // 为对象的公有属性赋值
        m.invoke(obj, "X-man");           // 调用对象的公有方法

    }
```

[泛型](/java/数据类型?id=泛型)在编译时检查类型安全，编译过后泛型被擦除、实际类型才确定。反射是在编译期模拟 java 运行时的环境读取和调用程序，因此不能获得泛型的实际类型。但可以通过反射越过泛型检查：

*在 String 泛型的集合中，你甚至可以添加一个 Integer 类型的值。*

```java
public class Demo {
    public static void main(String[] args) throws Exception{
        ArrayList<String> strList = new ArrayList<>();    
        Class listClass = strList.getClass(); 
        Method m = listClass.getMethod("add", Object.class);
        m.invoke(strList, 100);
    }
}
```

---

## 访问权限

private和protected不能修饰外部类的原因<br>
使用private修饰，表示该类的成员只能在类的内部访问。<br>
使用protected修饰，表示该类的成员可以被类的内部、同包下的其它类以及该类的子类访问。<br>

从组织结构来分析：

类的成员（包过变量、方法、内部类等）的上层结构是类，而类的上层结构是包。<br>
如果类可以使用private来修饰，表示该包下的这个类不能被其它类访问，那么该类也失去了存在的意义，所以不能使用private来修饰类。<br>
如果类A用protected修饰，与类A不同包的类B想要访问类A的话，类B就必须是继承类A的（或者说类B必须为类A的子类），但是类B继承类A的前提又是类B可以访问到类A，仔细想想会发现这里是冲突的，其实这就说明了为什么不能用protected来修饰外部类。

private 类访问<br>
default 包访问<br>
protected 继承访问<br>

这个修饰符在继承体系中成员对于子类可见，但是这个修饰符对于类没有意义

public

---

## 缓冲池

什么是缓冲池?
缓冲池范围一般都是[-128,127],除了Character
那些包装类具有缓冲池?
- Byte
- Short
- Character
- Integer
- Long


## 关键字

- final

  可以声明的位置
    - **类** 该类不能被继承
    - **方法** 该方法不能被重写
    - **成员变量** 该变量不能被修改
      - **基本类型** 使数值不能够被修改
      - **引用类型** 引用不能变，但是被引用变量的对象本身可以被修改

final修饰的变量也可以被修改<br>
使用java提供的反射技术，并且关闭安全校验也可以修改其值

- static

  可以声明的位置
    - 类
    - 方法
    - 成员变量
    - 静态代码块
    - 初始化顺序

静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。
1. 父类（静态变量，静态代码块）
2. 子类（静态变量，静态代码块）
3. 父类（实例变量，普通代码块）
4. 父类构造方法
5. 子类（实例变量，普通代码块）
6. 子类构造方法